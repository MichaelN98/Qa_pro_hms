'number' + 3 + 3   
/*
'number' - это строка, 3 - это число, 3 - это число
так как один из операндов строка, то идет преобразования числа в строку и знаком "+" оно соединяется
Результат: 'number33'
 */

null + 3
/*
null рассматривает как "0" в арифметических операция  и получается 0 + 3 
Результат: 3
*/

5 && "qwerty" 
/*
&& - повертає true, якщо обидва операнди є true, інакше повертає false.
5 = number (истинное потому что не нулевое число)
"qwerty" = string (не пустая строка тоже истина)
Ркзультат: true
*/

+'40' + +'2' + "hillel"; 
/*
+'40' - унарный + преобразует строку в число 40
+'2' - унарный + преобразует строку в число 2 
"hilell" - строка
Поэтому, числа сумируются 40+2 = 42 и так как один из операндов строка, то идет преобразования числа в строку и знаком "+" оно соединяется
Результат: '42hillel'
*/

'10' - 5 === 6;
/*
'10' = преобразуется в число из-за оператора -, поэтому 10-5=5
"===" - это оператор строгого сравнения, левая операнд будет равен 5, а правый будет равен 6, 5===6
Результат: false
*/

true + false
/*
Из-за арифметического оператора +, True и False будут преобразованы в числа 1 и 0 соотвествено 
1 + 0 = 1
Результат: 1
*/

'4px' - 3
/*
'4px' - сторока которая не может быть преобразована в число
 при вычитании числа из строки результат всегда NaN
Результат: NaN
*/

'4' - 3
/*
'4' - стринга, которая преобразуется в число из-за оператора -
поэтому 4-3=1
Результат: 1
*/

'6' + 3 ** 0;
/*
Дедвем сначала возведение к степени 3 ** 0, ,будет = 1(любое число в степени 0 =1).
'6' + 1 произойдет конкатенация из-за того что '6' строка
Результат:61
*/

12 / '6'
/*
Оператор "/" приводит к числовому типу '6'
Результат:2
*/


'10' + (5 === 6);
/*
(5 === 6) будет false  потому что оператор "=== " строгого сравнения
'10' стринга + false будет просто конкатенацию строк
Результат: '10false'
*/

null == ''
/*
//Просто так вирішили. undefined і null рівні один одному і НІ ЩО БІЛЬШЕ!
Результат: true
*/

3 ** (9 / 3);
/*
простая логическая цепочка, сначала в скобках 9/3=3 и возврдим в степень 3 **  3
Результат: 27
*/

!!'false' == !!'true'
/*
'false' - строка, которая при использовании двойного оператора отрицания !! будет преобразована в true потому что непустая строка считается истинной.
'true' - эта строка в логическом контексте будет преобразована в true.
!!'false' -  преобразование строки 'false' в true, а затем еще одно отрицание преобразует результат обратно в false.
!!'true' - реобразование строки 'true' в true, а затем еще одно отрицание преобразует результат обратно в false.
 !!'false' == !!'true' будет True, потому что оба операнда после преобразования будут равны false.
Результат: true
* все равно не совсем понятно, немного запутанно
*/

0 || '0' && 1
/*
- **`&&`** (логическое "и"): Возвращает **`true`**, если оба операнда истинны.
- **`||`** (логическое "или"): Возвращает **`true`**, если хотя бы один из операндов истинен.

'0' && 1 =  '0' считается "истинным", поэтому результат этой части выражения будет 1.
0 || 1 = 0 считается "ложным", поэтому результат выражения будет 1.
Результат: 1
*/

(+null == false) < 1;
/*
(+null == false) - унарный + перведет в числвое значение null=0, поэтому 0==false при не строгом сравнении
(+null == false) = true
при сравнении логического значения (true) с числовым значением (1), true будет преобразовано в 1, и сравнение 1 < 1 будет ложным.
Результат: false
*/

false && true || true
/*
false && true = логическое И возвращает false, так как оба операнда должны быть истинными для получения истинного результата.
false || true = логическое ИЛИ возвращает true, так как один из операндов (true) является истинным.
Результат: true
*/

false && (false || true);
/*
false || true -  вернет true, так как один из операндов (true) является истинным.
false &&  true -  вернет false, так как один из операндов (false) является ложным.
Результат: false
*/

(+null == false) < 1 ** 5;
/*
+null -  Унарный плюс преобразует null в числов null = 0 = false
(0 == false) - false == false возвращает true
1 ** 5 - такое возведение в степень равно 1
true в цифровом значение = 1 поэтому 1==1 будет false
Результат: false
*/

